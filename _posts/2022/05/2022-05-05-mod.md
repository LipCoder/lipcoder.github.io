---
title: 나머지
date: 2022-05-05 22:56:00 +09:00
categories: [이산수학]
tags: [나머지, 패리티, 해밍코드, 규칙, 주기성, 홀수, 짝수, 한 붓 그리기, 그룹 나누기]     # TAG names should always be lowercase
---

{% katexmm %}

## 나머지
---
### 나눗셈
나눗셈은 `특정 숫자`를 기준으로 `그룹`으로 나누는 행위이다.  
<br>
<br>

### 나눗셈의 부산물: 나머지

 - 나눗셈을 할 때 **특정 숫자 기준에 맞지 않아 나누어 떨어지지 않고 남는 것**
 - 나머지가 얼마인가에 따라서 어떤 그룹에 속하게 될 것인지 정해진다.

<br>
<br>

### 응용 

 - 특정 숫자 기준이라 함은 어떤 규칙에 따라 `주기성`을 가지고 있다는 뜻과 같다. 
 - 여기서 `나머지`는 특정 주기를 완료하는 횟수만큼 도달하지 못함을 뜻한다.<br>(주기성을 가지고 있다 가정하면, 나머지는 **그 주기에 속한다**.)
 - `주기성`, `그룹나누기`, `나머지`를 잘 이용하면 아무리 큰 문제라도 간단하게 풀 수 있다. 

<br>
<br>

## 응용 문제
---
### 요일 퀴즈-1
> Q. 오늘은 일요일이다. 그렇다면 100일 후에는 무슨 요일인가?

##### 방법 확인

 - 규칙
	 - 일주일은 7일이다.
	 - 오늘의 요일은 7일 주기로 다시 돌아온다.
 - 주기성 
	 - 현재 요일 + 7일 = 현재 요일
 - 나머지
	 - n일 후 요일 = 현재 요일 + ($n\div7$ 나머지)요일 

<br>
> A. 일요일의 100일 후 
> $$ = 일요일 + ({100}\div{7}의 나머지)$$ $$ = 일요일 + 2 $$ $$ =화요일  $$

<br>

### 요일 퀴즈-2
규칙만 안다면 아무리 큰 문제라도 풀 수 있다.  
큰 문제를 나눌 수 있기 때문이다.  

> Q. 오늘은 일요일이다. 그렇다면 $10^{100}$일 후에는 무슨 요일인가?

##### 방법 확인

 - 규칙
	 - $10^n$에서 n의 수를 높여가며 규칙을 확인한다.

|n|몇 일후|나머지|요일|
|:--|:--|:--|:--|
|0|1일 후|$1\div7=0...1$|월요일|
|1|10일 후|$10\div7=1...3$|수요일|
|2|100일 후|$100\div7=14...2$|화요일|
|3|1000일 후|$1000\div7=142...6$|토요일|
|4|10000일 후|$10000\div7=14265...4$|목요일|
|5|100000일 후|$100000\div7=142857...5$|금요일|
|6|1000000일 후|$1000000\div7=1428571...1$|월요일|
|...|...|...|...|

$$1\Rightarrow3\Rightarrow2\Rightarrow6\Rightarrow4\Rightarrow5 \Rightarrow 반복$$ 

- 주기성
	- 6번 순회하며 "월, 수, 화, 토, 목, 금" 순으로 순회한다.
- 나머지
	- $10^n$일 후 요일 = 순회규칙에서 ($n\div6$ 나머지)번째 요일

<br>

> A. $10^{100}$일 후 요일
> $$100\div6 = 16...4$$ $$월(0), 수(1), 화(2), 토(3), 목(4), 금(5)이므로$$ $$ 정답은\space 목요일 $$ 

<br>
<br>

### 거듭제곱 퀴즈
---
> Q. $1234567^{987654321}$에서 1의 자리는 얼마인가?

##### 방법 확인
1의 자리를 구하기만 하면 되므로, 1의 자리만 생각한다.
1234567의 1의 자리수가 7이므로 $7^n$의 1의 자리수 규칙을 찾는다.

 - 규칙
	 - $7^n$에서 n을 높이며 규칙을 확인한다. 

|$1234567^n$|$7^n$|1의 자리수|
|:--|:--|:--|
|$123456^0$의 1의 자리|$7^0$의 1의 자리|1|
|$123456^1$의 1의 자리|$7^1$의 1의 자리|7|
|$123456^2$의 1의 자리|$7^2$의 1의 자리|9|
|$123456^3$의 1의 자리|$7^3$의 1의 자리|3|
|$123456^4$의 1의 자리|$7^4$의 1의 자리|1|
|...|...|...|

$$ 1\Rightarrow7\Rightarrow9\Rightarrow3\Rightarrow 반복 $$

 - 주기성
	 - 4번 순회하며 "1, 7, 9, 3" 순으로 순회한다.
 - 나머지
	 - $1234567^n$의 1의 자리수 = 순회규칙에서 ($n\div4$ 나머지)번째 수

<br>

> A. $1234567^{987654321}$  
> $$ = 7^{987654321} $$ $$= 987654321\div4 $$ $$= 나머지\space1$$ $$ 1(0), 7(1), 9(2), 3(3) 이므로 $$ $$ 정답은 7$$

<br>
<br>

### 친구 찾기
![find-friend](/assets/img/posting/mod/find-friend.PNG){:width="70%"}

> Q. 12개월 후 친구가 A 마을에 있을 확률을 구하라.  
> 
> - 한달에 한번은 꼭 마을을 옮겨야 한다.  
> - 현재 마을에서 주변 마을로만 이동 가능하다.  

##### 방법 확인
처음부터 옮겨 다니며 규칙을 찾는다. 

1. 0번째 이동(현재)

![friend-0](/assets/img/posting/mod/friend-0.PNG){:width="50%"}

현재 친구는 G 마을에 있다. 

2. 1번째 이동(1개월)

![friend-1](/assets/img/posting/mod/friend-1.PNG){:width="50%"}

G의 주변마을 `C, F, H` 중 하나로 이동한다.

3. 2번째 이동(2개월)

![friend-2](/assets/img/posting/mod/friend-2.PNG){:width="50%"}

C, F, H의 주변마을 중 하나로 이동한다.  
C(B, D, G), F(B, E, G), H(D, E, G)  
중복을 제거하면 `B, D, E, G` 마을로 이동할 수 있다.  

4. 3번째 이동(3개월)

![friend-3](/assets/img/posting/mod/friend-3.PNG){:width="50%"}

B, D, E, G의 주변마을 중 하나로 이동한다.  
B(A, C, F), D(A, C, H), E(A, F, H), G(C, F, H)  
중복을 제거하면 `A, C, F, H` 마을로 이동할 수 있다.  

규칙을 이용하여 분할해보면 다음과 같다.  

 - 짝수 개월차 : `B, D, E, G` 마을로 이동 가능하다. 
 - 홀수 개월차 : `A, C, F, H` 마을로 이동 가능하다.

<br>

> A. 짝수 개월차는 `B, D, E, G` 마을로만 이동이 가능하므로, 친구가 12개월 후 A 마을에 있을 확률은 0%이다. 

여기서 핵심은 각 마을에 있을 확률이 아니라 `홀수개월 마을`과 `짝수개월 마을`로 **`그룹화`** 시켜서 생각하는 것이다. 
<br>
<br>

### 타일 깔기 퀴즈
![tile-question](/assets/img/posting/mod/tile-question.PNG){:width="80%"}

> Q. 그림과 같은 모양의 욕실이 있다. 이 욕실에 오른쪽과 같은 타일을 빈틈없이 깔 수 있는가?   
> (단, 타일은 쪼개서 깔 수 없다.)  

##### 해결 방법
여기서도 핵심은 규칙에 맞게 그룹화 시키는 것이다.
그룹화의 기준을 위해 타일을 균열하게 검은색으로 칠한다. 

![tile-answer](/assets/img/posting/mod/tile-answer.PNG){:width="80%"}

이를 통해 검은 타일과 흰 타일로 그룹화 할 수 있게 되었다.  
그룹화하여 개수가 어떻게 되는지 살펴보면 다음과 같다. 
 - 검은 타일 : 30개
 - 흰 타일 : 32개

<br>

> A.  
> - 검은 타일과 흰색 타일의 개수가 일치해야 빈틈없이 깔 수 있다.  
> - 흰 타일이 2개 더 많으므로 타일을 빈틈없이 깔 수 없다.  

<br>
<br>

### 한붓그리기 (쾨니히스베르크의 다리)
![bridge-question](/assets/img/posting/mod/bridge-question.PNG){:width="90%"}

> Q. 다음과 같은 다리가 있다. 이 다리를 모두 건널 수 있다면 그 방법을 표시하고, 건너지 못한다면 왜 그런지 증명하라.
> 1. 한 번 건넌 다리는 다시 건널 수 없다.
> 2. 각 구역은 몇 번 가도 상관 없다.
> 3. 어느 구역에서 출발하여도 상관없다.
> 4. 출발한 구역으로 돌아올 필요는 없다. 

##### 해결 방법

 - 단순화하여 생각해본다.
 - 천재 수학자 오일러는 이 문제를 단순화시켜 규칙을 만들어 풀었다.

![bridge-answer](/assets/img/posting/mod/bridge-answer.PNG){:width="40%"}

A, B, C, D를 정점이라 하고, 각 다리와 정점을 연결하는 점을 꼭짓점이라고 하자.
 - 규칙 
	 - 출발하거나, 도착할때 정점을 한 번 지나게 된다. 지날 수 있는 꼭짓점이 **하나** 줄어든다. 
	 - 정점을 가로지를 때 지날 수 있는 꼭짓점이 **두 개** 줄어든다.

이를 이용하여 한 붓 그리기가 가능한 조건은 다음과 같다. 
> **모든 꼭짓점이 짝수**이거나 **홀수점이 2개**인 경우 한 붓 그리기가 가능하다.
> 
> A. 문제의 모든 정점의 꼭짓점 개수가 홀수점이므로 해당 다리는 한 붓 그리기가 불가능하다. (모든 다리를 건널 수 없다.)

<br>
<br>
<br>

## 패리티
---
### 패리티란?
패리티(Parity)는 사전적인 의미로 다음과 같다.

> 1과 0으로 성립된 수열에 있어서, 1의 개수의 짝/홀을 나타내는 말. 그 개수가 짝수일 때 패리티는 0, 홀수일때 패리티는 1이라고 함.

<br>
<br>

### 패리티의 사용처

컴퓨터는 2진법 체계로 작동하기 때문에 패리티 조건에 알맞는다.  
컴퓨터공학에서 패리티의 특성을 이용해 오류를 검사한다. 이를 `패리티 검사`라고 한다.  
 - 하드디스크 RAID, 네트워크 통신(장거리), BUS 통신, 등에서 패리티 검사를 사용 
 - 일상 생활에서도 사용되는데 대표적으로 주민번호 위조 확인과 바코드 오류 확인 등이 있다.

<br>
<br>

### 패리티 검사 방법
##### 전제 조건

![parity-0](/assets/img/posting/mod/parity-0.PNG){:width="100%"}
 
패리티 검사를 위해서는 데이터를 표현하는 비트 외에 하나의 패리티 비트가 필요하다. 데이터 비트 1의 개수를 기준으로 패리티 비트에 1과 0이 정해진다.

##### 홀수/짝수 패리티

![parity-1](/assets/img/posting/mod/parity-1.PNG){:width="100%"}

1의 개수가 짝수인가, 홀수인가를 기준으로 `짝수 패리티`와 `홀수 패리티`로 나눌 수 있다.
 - 짝수 패리티는 데이터의 비트를 짝수에 맞춘다.
	 - 데이터 비트 수가 `짝수이면 0`, `홀수이면 1`이 된다.
 - 홀수 패리티는 데이터의 비트를 홀수에 맞춘다.
	 - 데이터 비트 수가 `짝수이면 1`, `홀수이면 0`이 된다.

##### 오류 검사
전송을 받은 곳에서는 패리티 비트를 기준으로 오류를 검사한다.
 - 만약 짝수 패리티를 기준으로 한다면..
	 - 짝수 = **올바른 데이터** 
	 - 홀수 = **오류가 생긴 데이터** 
 - 만약 홀수 패리티를 기준으로 한다면..
	 - 짝수 = **오류가 생긴 데이터** 
	 - 홀수 = **올바른 데이터** 
<br>
<br>

### 오류가 발생하는 이유
대표적인 원인은 다음과 같다. 

 1. 감쇄 : 전송 과정에서 거리에 따라 약해지는 현상
 2. 지연 왜곡 : 여러 신호를 전달했을 경우 주파수에 따라 속도가 달라지며 생기는 오류
 3. 상호 변조 잡음 : 주파수들이 하나의 전송 매체를 공유할 때 주파수 간의 합이나 차로 새로운 주파수가 생겨 잡음이 발생
 4. 충격 잡음 : 외부 충격, 기계적 통신 시스템 결함 등 순간적으로 높은 진폭이 발생하는 잡음

오류의 원인으로 전송 중 노이즈가 발생하면 0을 1로 인식하는 문제가 발생할 수 있다.  데이터링크 계층(2 Layer)에서 이러한 노이즈를 검출하는 역할을 한다.  
<br>
<br>

### 패리티 검사의 한계점
크게 두가지로 나뉜다. 

 1. 오류 검출만 가능하다. 그 오류를 `복구할 수 있는 수단은 없다`. 
 2. `노이즈가 발생한 비트 수가 짝수 개`일 경우 오류 검출이 불가능하다. 
	 --> 홀수 패리티를  기준으로 비트의 1의 개수가 총 3개일 경우, 2개의 비트에 노이즈가 발생해 1이 되면 1의 개수는 총 5개이다.
	 하지만 패리티 검사 시 1의 개수는 홀수 개 이므로 **오류로 인식하지 않는다**. 
<br>
<br>
<br>

## 한계의 해결책 : 해밍코드
### 해밍코드란?
해밍코드(Hamming Code)는 1950년 벨 연구소의 Richard Hamming에 의해 고안되었다.  
해밍코드를 사용하면 패리티 검사의 한계점을 극복 할 수 있다. 
<br>
<br>

### 해밍코드 작동 방식
해밍코드는 총 3가지 단계를 거친다.
 - 생성
 - 검출
 - 수정

##### 패리티 추가 비트 수 계산
몇 개의 패리티 비트를 추가할 지를 계산한다.

 - $2^P >= P + m + 1$을 만약하는 최소값 P를 구한다.
	 - m은 `원본 데이터의 비트 수`이다.
	 - P는 `추가할 최소 패리티 비트 수`가 된다.

##### 패리티 비트 데이터 생성
패리티 비트 $P_n$는 $2^{n-1}$번째 자리에 각각 생긴다.  
$P_n$은 자기 범위에 대해서 짝수/홀수 패리티를 가진다.  
> $P_n$의 범위  
> 
> $1 \backsim (m + P)$를 2진수로 표현한 x에서 n번째 비트가 1인 x의 집합 

이론만 봐서는 잘 이해가 되지 않는다. 그러므로 예제를 통해 다시 설명하려고 한다. 
<br>
<br>

### 해밍코드 예제
원본 데이터 $1001_2$에 대해서 해밍코드를 만들어보자.

##### 생성
순서에 따라 몇 개의 패리티 비트를 추가할지를 계산한다.  
$$ m = 4개 $$ $$ P^1 < 1 + 4 + 1 (X) $$ $$ P^2 < 2 + 4 + 1 (X) $$ $$ P^3 = 3 + 4 + 1 (O) $$

조건을 통해 구한 최소 P의 개수는 3개이다.  

이제 패리티 비트 자리를 추가하고 새로운 데이터를 만든다.  
$$ n = (1 \backsim P)이므로, 1\leqq n \leqq 3  $$ 
생성되는 패리티 비트는 $P_1, P_2, P_3$로 각각 $2^0, 2^1, 2^2$번째 자리에 추가된다.  

![hamming-0](/assets/img/posting/mod/hamming-0.PNG){:width="70%"}

$P_n$의 범위 공식을 이용하여 각 패리티 비트가 담당할 비트 범위를 구한다. 
 
![hamming-1](/assets/img/posting/mod/hamming-1.PNG){:width="70%"}

표에서 볼 수 있듯, $P_1  \backsim P_3$의 조합은 비트 위치를 모두 포함하고 있다. 

 - $P_3$ 패리티 비트는$(4, 5, 6, 7)$번째 위치의 비트를 관리한다.
 - $P_2$ 패리티 비트는$(2, 3, 6, 7)$번째 위치의 비트를 관리한다.
 - $P_1$ 패리티 비트는$(1, 3, 5, 7)$번째 위치의 비트를 관리한다.

$P_n$ 범위를 바탕으로 짝수 패리티를 규칙으로 해밍코드를 생성한다. 

![hamming-2](/assets/img/posting/mod/hamming-2.PNG){:width="70%"}

 - $P_3$은 $(4, 5, 6, 7)$번째 비트를 관리하므로, 짝수 패리티를 만족하려면 1이 되어야 함
	 - 1 + 0 + 0 + $P_3$가 짝수가 되려면 $P_3 = 1$
 - $P_2$은 $(2, 3, 6, 7)$번째 비트를 관리하므로, 짝수 패리티를 만족하려면 0이 되어야 함
	 - $P_2$ + 1 + 0 + 1가 짝수가 되려면 $P_2 = 0$
 - $P_1$은 $(1, 3, 5, 7)$번째 비트를 관리하므로, 짝수 패리티를 만족하려면 1이 되어야 함
	 - $P_2$ + 1 + 0 + 1가 짝수가 되려면 $P_1 = 1$

따라서 원본 데이터 $1001_2$에 대한 해밍 코드는 $1001100_2$이 된다. 
<br>

##### 검출
이제 이 데이터를 송신한다. 잡음이 없었다면 알맞은 데이터가 전송되었을 것이다. 하지만, 잡음이 생겨 $1011100_2$을 수신했다고 가정하자.  

수신측에서는 이미 짝수 패리티 기반의 해밍코드를 사용하여 오류를 검출하고 수정할 것임을 알고 있다.  

$1011100_2$에서 $2^{n-1}$번째 비트들을 뽑아서 검사한다.  

> $P_1$ 검사

![hamming-3](/assets/img/posting/mod/hamming-3.PNG){:width="70%"}

첫번째 패리티는 `1, 3, 5, 7` 번째 비트를 검사한다.  
$1+1+1+0=3$개로 짝수 패리티 조건에 만족하지 않는다. 때문에 $P_1$에 대한 유효성 검사 비트($P_1'$)의 값은 1이다.  

> $P_2$ 검사

![hamming-4](/assets/img/posting/mod/hamming-4.PNG){:width="70%"}

첫번째 패리티는 `2, 3, 6, 7` 번째 비트를 검사한다.  
$1+0+1+0=2$개로 짝수 패리티 조건에 만족한다. 때문에 $P_2$에 대한 유효성 검사 비트($P_2'$)의 값은 0이다. 

> $P_3$ 검사

![hamming-5](/assets/img/posting/mod/hamming-5.PNG){:width="70%"}

첫번째 패리티는 `4, 5, 6, 7` 번째 비트를 검사한다.  
$1+0+1+1=3$개로 짝수 패리티 조건에 만족하지 않는다. 때문에 $P_3$에 대한 유효성 검사 비트($P_3'$)의 값은 1이다.  

> $$P_1' = 1, P_2' = 0, P_3' = 1$$ $$ E=P_3'P_2'P_1' $$ $$ = 101_2 $$

오류 위치를 표시하는 E는 101로 십진법으로 변환하면 5이다. 결론적으로 **5번째에 위치한 비트**가 잘못 되었음을 확인하였다.  
<br>

#####  수정
5번째 비트에 노이즈가 발생하였으므로 5번째 비트 값을 1에서 0으로 수정한다.  

이후 모든 오류를 찾아 수정할때까지 계속해서 ($검출 \Rightarrow 수정$) 과정을 반복한다.
<br>
<br>

### 해밍코드의 장단점

 - 장점
	 - 패리티 오류 검사의 한계점을 모두 극복 할 수 있다. 
 - 단점
	 - 패리티 검사에 비해 필요한 비트 수가 많아진다. 


{% endkatexmm %}