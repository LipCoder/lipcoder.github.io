[ { "title": "나머지", "url": "/posts/mod/", "categories": "이산수학", "tags": "나머지, 패리티, 해밍코드, 규칙, 주기성, 홀수, 짝수, 한 붓 그리기, 그룹 나누기", "date": "2022-05-05 22:56:00 +0900", "snippet": "나머지나눗셈나눗셈은 특정 숫자를 기준으로 그룹으로 나누는 행위이다.나눗셈의 부산물: 나머지 나눗셈을 할 때 특정 숫자 기준에 맞지 않아 나누어 떨어지지 않고 남는 것 나머지가 얼마인가에 따라서 어떤 그룹에 속하게 될 것인지 정해진다.응용 특정 숫자 기준이라 함은 어떤 규칙에 따라 주기성을 가지고 있다는 뜻과 같다. 여기서 나머지는 특정 주기를 완료하는 횟수만큼 도달하지 못함을 뜻한다.(주기성을 가지고 있다 가정하면, 나머지는 그 주기에 속한다.) 주기성, 그룹나누기, 나머지를 잘 이용하면 아무리 큰 문제라도 간단하게 풀 수 있다.응용 문제요일 퀴즈-1 Q. 오늘은 일요일이다. 그렇다면 100일 후에는 무슨 요일인가?방법 확인 규칙 일주일은 7일이다. 오늘의 요일은 7일 주기로 다시 돌아온다. 주기성 현재 요일 + 7일 = 현재 요일 나머지 n일 후 요일 = 현재 요일 + (n÷7n\\div7n÷7 나머지)요일 A. 일요일의 100일 후 =일요일+(100÷7의나머지) = 일요일 + ({100}\\div{7}의 나머지)=일요일+(100÷7의나머지) =일요일+2 = 일요일 + 2 =일요일+2 =화요일 =화요일 =화요일요일 퀴즈-2규칙만 안다면 아무리 큰 문제라도 풀 수 있다.큰 문제를 나눌 수 있기 때문이다. Q. 오늘은 일요일이다. 그렇다면 1010010^{100}10100일 후에는 무슨 요일인가?방법 확인 규칙 10n10^n10n에서 n의 수를 높여가며 규칙을 확인한다. n 몇 일후 나머지 요일 0 1일 후 1÷7=0...11\\div7=0...11÷7=0...1 월요일 1 10일 후 10÷7=1...310\\div7=1...310÷7=1...3 수요일 2 100일 후 100÷7=14...2100\\div7=14...2100÷7=14...2 화요일 3 1000일 후 1000÷7=142...61000\\div7=142...61000÷7=142...6 토요일 4 10000일 후 10000÷7=14265...410000\\div7=14265...410000÷7=14265...4 목요일 5 100000일 후 100000÷7=142857...5100000\\div7=142857...5100000÷7=142857...5 금요일 6 1000000일 후 1000000÷7=1428571...11000000\\div7=1428571...11000000÷7=1428571...1 월요일 … … … … 1⇒3⇒2⇒6⇒4⇒5⇒반복1\\Rightarrow3\\Rightarrow2\\Rightarrow6\\Rightarrow4\\Rightarrow5 \\Rightarrow 반복1⇒3⇒2⇒6⇒4⇒5⇒반복 주기성 6번 순회하며 “월, 수, 화, 토, 목, 금” 순으로 순회한다. 나머지 10n10^n10n일 후 요일 = 순회규칙에서 (n÷6n\\div6n÷6 나머지)번째 요일 A. 1010010^{100}10100일 후 요일100÷6=16...4100\\div6 = 16...4100÷6=16...4 월(0),수(1),화(2),토(3),목(4),금(5)이므로월(0), 수(1), 화(2), 토(3), 목(4), 금(5)이므로월(0),수(1),화(2),토(3),목(4),금(5)이므로 정답은 목요일 정답은\\space 목요일 정답은 목요일거듭제곱 퀴즈 Q. 12345679876543211234567^{987654321}1234567987654321에서 1의 자리는 얼마인가?방법 확인1의 자리를 구하기만 하면 되므로, 1의 자리만 생각한다.1234567의 1의 자리수가 7이므로 7n7^n7n의 1의 자리수 규칙을 찾는다. 규칙 7n7^n7n에서 n을 높이며 규칙을 확인한다. 1234567n1234567^n1234567n 7n7^n7n 1의 자리수 1234560123456^01234560의 1의 자리 707^070의 1의 자리 1 1234561123456^11234561의 1의 자리 717^171의 1의 자리 7 1234562123456^21234562의 1의 자리 727^272의 1의 자리 9 1234563123456^31234563의 1의 자리 737^373의 1의 자리 3 1234564123456^41234564의 1의 자리 747^474의 1의 자리 1 … … … 1⇒7⇒9⇒3⇒반복 1\\Rightarrow7\\Rightarrow9\\Rightarrow3\\Rightarrow 반복 1⇒7⇒9⇒3⇒반복 주기성 4번 순회하며 “1, 7, 9, 3” 순으로 순회한다. 나머지 1234567n1234567^n1234567n의 1의 자리수 = 순회규칙에서 (n÷4n\\div4n÷4 나머지)번째 수 A. 12345679876543211234567^{987654321}1234567987654321=7987654321 = 7^{987654321} =7987654321 =987654321÷4= 987654321\\div4 =987654321÷4 =나머지 1= 나머지\\space1=나머지 1 1(0),7(1),9(2),3(3)이므로 1(0), 7(1), 9(2), 3(3) 이므로 1(0),7(1),9(2),3(3)이므로 정답은7 정답은 7정답은7친구 찾기 Q. 12개월 후 친구가 A 마을에 있을 확률을 구하라. 한달에 한번은 꼭 마을을 옮겨야 한다. 현재 마을에서 주변 마을로만 이동 가능하다. 방법 확인처음부터 옮겨 다니며 규칙을 찾는다. 0번째 이동(현재)현재 친구는 G 마을에 있다. 1번째 이동(1개월)G의 주변마을 C, F, H 중 하나로 이동한다. 2번째 이동(2개월)C, F, H의 주변마을 중 하나로 이동한다.C(B, D, G), F(B, E, G), H(D, E, G)중복을 제거하면 B, D, E, G 마을로 이동할 수 있다. 3번째 이동(3개월)B, D, E, G의 주변마을 중 하나로 이동한다.B(A, C, F), D(A, C, H), E(A, F, H), G(C, F, H)중복을 제거하면 A, C, F, H 마을로 이동할 수 있다.규칙을 이용하여 분할해보면 다음과 같다. 짝수 개월차 : B, D, E, G 마을로 이동 가능하다. 홀수 개월차 : A, C, F, H 마을로 이동 가능하다. A. 짝수 개월차는 B, D, E, G 마을로만 이동이 가능하므로, 친구가 12개월 후 A 마을에 있을 확률은 0%이다.여기서 핵심은 각 마을에 있을 확률이 아니라 홀수개월 마을과 짝수개월 마을로 그룹화 시켜서 생각하는 것이다. 타일 깔기 퀴즈 Q. 그림과 같은 모양의 욕실이 있다. 이 욕실에 오른쪽과 같은 타일을 빈틈없이 깔 수 있는가? (단, 타일은 쪼개서 깔 수 없다.)해결 방법여기서도 핵심은 규칙에 맞게 그룹화 시키는 것이다.그룹화의 기준을 위해 타일을 균열하게 검은색으로 칠한다.이를 통해 검은 타일과 흰 타일로 그룹화 할 수 있게 되었다.그룹화하여 개수가 어떻게 되는지 살펴보면 다음과 같다. 검은 타일 : 30개 흰 타일 : 32개 A. 검은 타일과 흰색 타일의 개수가 일치해야 빈틈없이 깔 수 있다. 흰 타일이 2개 더 많으므로 타일을 빈틈없이 깔 수 없다. 한붓그리기 (쾨니히스베르크의 다리) Q. 다음과 같은 다리가 있다. 이 다리를 모두 건널 수 있다면 그 방법을 표시하고, 건너지 못한다면 왜 그런지 증명하라. 한 번 건넌 다리는 다시 건널 수 없다. 각 구역은 몇 번 가도 상관 없다. 어느 구역에서 출발하여도 상관없다. 출발한 구역으로 돌아올 필요는 없다. 해결 방법 단순화하여 생각해본다. 천재 수학자 오일러는 이 문제를 단순화시켜 규칙을 만들어 풀었다.A, B, C, D를 정점이라 하고, 각 다리와 정점을 연결하는 점을 꼭짓점이라고 하자. 규칙 출발하거나, 도착할때 정점을 한 번 지나게 된다. 지날 수 있는 꼭짓점이 하나 줄어든다. 정점을 가로지를 때 지날 수 있는 꼭짓점이 두 개 줄어든다. 이를 이용하여 한 붓 그리기가 가능한 조건은 다음과 같다. 모든 꼭짓점이 짝수이거나 홀수점이 2개인 경우 한 붓 그리기가 가능하다. A. 문제의 모든 정점의 꼭짓점 개수가 홀수점이므로 해당 다리는 한 붓 그리기가 불가능하다. (모든 다리를 건널 수 없다.)패리티패리티란?패리티(Parity)는 사전적인 의미로 다음과 같다. 1과 0으로 성립된 수열에 있어서, 1의 개수의 짝/홀을 나타내는 말. 그 개수가 짝수일 때 패리티는 0, 홀수일때 패리티는 1이라고 함.패리티의 사용처컴퓨터는 2진법 체계로 작동하기 때문에 패리티 조건에 알맞는다.컴퓨터공학에서 패리티의 특성을 이용해 오류를 검사한다. 이를 패리티 검사라고 한다. 하드디스크 RAID, 네트워크 통신(장거리), BUS 통신, 등에서 패리티 검사를 사용 일상 생활에서도 사용되는데 대표적으로 주민번호 위조 확인과 바코드 오류 확인 등이 있다.패리티 검사 방법전제 조건패리티 검사를 위해서는 데이터를 표현하는 비트 외에 하나의 패리티 비트가 필요하다. 데이터 비트 1의 개수를 기준으로 패리티 비트에 1과 0이 정해진다.홀수/짝수 패리티1의 개수가 짝수인가, 홀수인가를 기준으로 짝수 패리티와 홀수 패리티로 나눌 수 있다. 짝수 패리티는 데이터의 비트를 짝수에 맞춘다. 데이터 비트 수가 짝수이면 0, 홀수이면 1이 된다. 홀수 패리티는 데이터의 비트를 홀수에 맞춘다. 데이터 비트 수가 짝수이면 1, 홀수이면 0이 된다. 오류 검사전송을 받은 곳에서는 패리티 비트를 기준으로 오류를 검사한다. 만약 짝수 패리티를 기준으로 한다면.. 짝수 = 올바른 데이터 홀수 = 오류가 생긴 데이터 만약 홀수 패리티를 기준으로 한다면.. 짝수 = 오류가 생긴 데이터 홀수 = 올바른 데이터 오류가 발생하는 이유대표적인 원인은 다음과 같다. 감쇄 : 전송 과정에서 거리에 따라 약해지는 현상 지연 왜곡 : 여러 신호를 전달했을 경우 주파수에 따라 속도가 달라지며 생기는 오류 상호 변조 잡음 : 주파수들이 하나의 전송 매체를 공유할 때 주파수 간의 합이나 차로 새로운 주파수가 생겨 잡음이 발생 충격 잡음 : 외부 충격, 기계적 통신 시스템 결함 등 순간적으로 높은 진폭이 발생하는 잡음오류의 원인으로 전송 중 노이즈가 발생하면 0을 1로 인식하는 문제가 발생할 수 있다. 데이터링크 계층(2 Layer)에서 이러한 노이즈를 검출하는 역할을 한다.패리티 검사의 한계점크게 두가지로 나뉜다. 오류 검출만 가능하다. 그 오류를 복구할 수 있는 수단은 없다. 노이즈가 발생한 비트 수가 짝수 개일 경우 오류 검출이 불가능하다. –&gt; 홀수 패리티를 기준으로 비트의 1의 개수가 총 3개일 경우, 2개의 비트에 노이즈가 발생해 1이 되면 1의 개수는 총 5개이다. 하지만 패리티 검사 시 1의 개수는 홀수 개 이므로 오류로 인식하지 않는다. 한계의 해결책 : 해밍코드해밍코드란?해밍코드(Hamming Code)는 1950년 벨 연구소의 Richard Hamming에 의해 고안되었다.해밍코드를 사용하면 패리티 검사의 한계점을 극복 할 수 있다. 해밍코드 작동 방식해밍코드는 총 3가지 단계를 거친다. 생성 검출 수정패리티 추가 비트 수 계산몇 개의 패리티 비트를 추가할 지를 계산한다. 2P&gt;=P+m+12^P &gt;= P + m + 12P&gt;=P+m+1을 만약하는 최소값 P를 구한다. m은 원본 데이터의 비트 수이다. P는 추가할 최소 패리티 비트 수가 된다. 패리티 비트 데이터 생성패리티 비트 PnP_nPn​는 2n−12^{n-1}2n−1번째 자리에 각각 생긴다.PnP_nPn​은 자기 범위에 대해서 짝수/홀수 패리티를 가진다. PnP_nPn​의 범위 1∽(m+P)1 \\backsim (m + P)1∽(m+P)를 2진수로 표현한 x에서 n번째 비트가 1인 x의 집합이론만 봐서는 잘 이해가 되지 않는다. 그러므로 예제를 통해 다시 설명하려고 한다. 해밍코드 예제원본 데이터 100121001_210012​에 대해서 해밍코드를 만들어보자.생성순서에 따라 몇 개의 패리티 비트를 추가할지를 계산한다.m=4개 m = 4개 m=4개 P1&lt;1+4+1(X) P^1 &lt; 1 + 4 + 1 (X) P1&lt;1+4+1(X) P2&lt;2+4+1(X) P^2 &lt; 2 + 4 + 1 (X) P2&lt;2+4+1(X) P3=3+4+1(O) P^3 = 3 + 4 + 1 (O) P3=3+4+1(O)조건을 통해 구한 최소 P의 개수는 3개이다.이제 패리티 비트 자리를 추가하고 새로운 데이터를 만든다.n=(1∽P)이므로,1≦n≦3 n = (1 \\backsim P)이므로, 1\\leqq n \\leqq 3 n=(1∽P)이므로,1≦n≦3 생성되는 패리티 비트는 P1,P2,P3P_1, P_2, P_3P1​,P2​,P3​로 각각 20,21,222^0, 2^1, 2^220,21,22번째 자리에 추가된다.PnP_nPn​의 범위 공식을 이용하여 각 패리티 비트가 담당할 비트 범위를 구한다.표에서 볼 수 있듯, P1∽P3P_1 \\backsim P_3P1​∽P3​의 조합은 비트 위치를 모두 포함하고 있다. P3P_3P3​ 패리티 비트는(4,5,6,7)(4, 5, 6, 7)(4,5,6,7)번째 위치의 비트를 관리한다. P2P_2P2​ 패리티 비트는(2,3,6,7)(2, 3, 6, 7)(2,3,6,7)번째 위치의 비트를 관리한다. P1P_1P1​ 패리티 비트는(1,3,5,7)(1, 3, 5, 7)(1,3,5,7)번째 위치의 비트를 관리한다.PnP_nPn​ 범위를 바탕으로 짝수 패리티를 규칙으로 해밍코드를 생성한다. P3P_3P3​은 (4,5,6,7)(4, 5, 6, 7)(4,5,6,7)번째 비트를 관리하므로, 짝수 패리티를 만족하려면 1이 되어야 함 1 + 0 + 0 + P3P_3P3​가 짝수가 되려면 P3=1P_3 = 1P3​=1 P2P_2P2​은 (2,3,6,7)(2, 3, 6, 7)(2,3,6,7)번째 비트를 관리하므로, 짝수 패리티를 만족하려면 0이 되어야 함 P2P_2P2​ + 1 + 0 + 1가 짝수가 되려면 P2=0P_2 = 0P2​=0 P1P_1P1​은 (1,3,5,7)(1, 3, 5, 7)(1,3,5,7)번째 비트를 관리하므로, 짝수 패리티를 만족하려면 1이 되어야 함 P2P_2P2​ + 1 + 0 + 1가 짝수가 되려면 P1=1P_1 = 1P1​=1 따라서 원본 데이터 100121001_210012​에 대한 해밍 코드는 100110021001100_210011002​이 된다. 검출이제 이 데이터를 송신한다. 잡음이 없었다면 알맞은 데이터가 전송되었을 것이다. 하지만, 잡음이 생겨 101110021011100_210111002​을 수신했다고 가정하자.수신측에서는 이미 짝수 패리티 기반의 해밍코드를 사용하여 오류를 검출하고 수정할 것임을 알고 있다.101110021011100_210111002​에서 2n−12^{n-1}2n−1번째 비트들을 뽑아서 검사한다. P1P_1P1​ 검사첫번째 패리티는 1, 3, 5, 7 번째 비트를 검사한다.1+1+1+0=31+1+1+0=31+1+1+0=3개로 짝수 패리티 조건에 만족하지 않는다. 때문에 P1P_1P1​에 대한 유효성 검사 비트(P1′P_1&#x27;P1′​)의 값은 1이다. P2P_2P2​ 검사첫번째 패리티는 2, 3, 6, 7 번째 비트를 검사한다.1+0+1+0=21+0+1+0=21+0+1+0=2개로 짝수 패리티 조건에 만족한다. 때문에 P2P_2P2​에 대한 유효성 검사 비트(P2′P_2&#x27;P2′​)의 값은 0이다. P3P_3P3​ 검사첫번째 패리티는 4, 5, 6, 7 번째 비트를 검사한다.1+0+1+1=31+0+1+1=31+0+1+1=3개로 짝수 패리티 조건에 만족하지 않는다. 때문에 P3P_3P3​에 대한 유효성 검사 비트(P3′P_3&#x27;P3′​)의 값은 1이다. P1′=1,P2′=0,P3′=1P_1&#x27; = 1, P_2&#x27; = 0, P_3&#x27; = 1P1′​=1,P2′​=0,P3′​=1 E=P3′P2′P1′ E=P_3&#x27;P_2&#x27;P_1&#x27; E=P3′​P2′​P1′​ =1012 = 101_2 =1012​오류 위치를 표시하는 E는 101로 십진법으로 변환하면 5이다. 결론적으로 5번째에 위치한 비트가 잘못 되었음을 확인하였다.수정5번째 비트에 노이즈가 발생하였으므로 5번째 비트 값을 1에서 0으로 수정한다.이후 모든 오류를 찾아 수정할때까지 계속해서 (검출⇒수정검출 \\Rightarrow 수정검출⇒수정) 과정을 반복한다.해밍코드의 장단점 장점 패리티 오류 검사의 한계점을 모두 극복 할 수 있다. 단점 패리티 검사에 비해 필요한 비트 수가 많아진다. " }, { "title": "논리", "url": "/posts/logic/", "categories": "이산수학", "tags": "명제, 논리, 카르카노 맵, 드모르간 법칙", "date": "2022-05-05 22:43:00 +0900", "snippet": "논리논리란? 자연 언어의 애매함을 없애고, 엄밀하고 정확하게 사물의 상태를 기술하고자 하는 도구논리의 목적 특정한 논리를 통한 입증이 옳은가를 측정하는 데 필요한 법칙을 제공한다. 컴퓨터 관련 학문이나 공학 등 여러 분야에 폭넓게 응용되며, 기술에 대한 이론적인 기반을 제공한다. 알고리즘의 설계와 증명 디지털 논리 회로의 설계 논리 프로그램 관련 분야 관계형 데이터베이스 이론 오토마타와 계산 이론 등.. 논리의 종류논리의 종류는 매우 다양하지만, 형식 논리에서는 크게 두 가지로 나눈다. 명제 논리 (Propositional Logic) 주어와 술어를 구분하지 않고 하나의 식으로 처리하여 참 또는 거짓을 판별하는 법칙 술어 논리 (Predicate Logic) 주어와 술어로 구분하여 참 또는 거짓을 판별하는 법칙여기에서는 이산수학 범주에 포함되는 명제 논리에 대해서 살펴보려고 한다. 명제명제란? 어떤 사고를 나타내는 문장 중 참이나 거짓을 객관적이고 명확하게 구분할 수 있는 문장이나 수학적 식을 말함 명제는 통상적으로 영문 소문자 p, q, r … 등으로 표기 명제가 참 또는 거짓의 값을 가질 때 그 값을 명제의 진리 값(Truth Value)이라고 함 명제의 진리 값은 다음과 같이 표기 참: T(true) 거짓: F(False) 명제는 T, F 두 가지 진리 값만 가지기 때문에 이진논리라고도 함즉, 명제는 반드시 True나 False 둘 중 하나가 된다.예시 (명제 예시1) 명제를 찾아보고, 명제인 경우 그것의 진리 값을 판별해보자. 바나나는 맛있다. 3x + 5y = 7 28은 4의 배수이다. 지금 어디로 가는 중입니까? (답) 1, 2, 4번은 참과 거짓을 판별할 수 없다.1번은 바나나 맛에 대한 개인 의견으로 참이라고 할 수는 없다.2번은 일차함수 다항식으로 x와 y값이 무수히 많아 참이라 할 수 없다.4번은 참과 거짓에 대한 명제가 아닌 단순한 질의문이다. 3번은 28이 4로 나누어 떨어지므로 4의 배수이다.그러므로 3번 명제의 진리값은 T(True)이다. ( 명제 예시 2 ) 아래의 명제들의 참, 거짓을 판별해보자. 6 &lt; 4 유채꽃은 노란색이다. 3 x 7의 결과는 홀수이다. 공기는 H2O로 표현된다. (답) 1, 4는 거짓이고 2, 3은 참이다.1번은 4가 6보다 작으므로 거짓이다.4번의 H2O는 물이므로 거짓이다.2번의 유채꽃 색은 노란색으로 참이다.3번의 값은 21로 홀수이므로 참이다.빠짐없고 겹치지 않는 분할 (1) '누락'은 없는가?(2) '중복'은 없는가?위 조건을 명제에 적용할 수 있는데, 이때 수직선을 그려 생각하면 도움이 된다. 수직선에서 잘못된 조건이나 프로그램의 오류는 경계 부분에서 자주 발생하기 때문에 항상 주의가 필요하다. 합성 명제란?하나의 문장이나 식으로 구성되어 있는 명제를 단순 명제라 한다. 여러 개의 단순 명제들이 논리 연산자(∽,∧,∨\\backsim, \\land,\\lor∽,∧,∨ 등..)로 연결되어 만들어진 명제를 합성명제라고 한다.1. 부정(Not A)임의의 명제 A가 주어졌을 때 그 명제에 대한 부정은 명제 A의 반대되는 진리 값을 가진다. A ∽\\backsim∽A ∽∽\\backsim\\backsim∽∽A true false true false true false 2. 논리곱(A and B)두 명제가 모두 참인 경우에만 참이라 하며 그렇지 않으면 거짓의 진리 값을 가진다. A B A ∧\\land∧ B true true true true false false false true false false false false 3. 논리합(A or B)한 명제만 참이면 두 명제에 대한 진리 값은 참이다.두 명제가 모두 거짓인 경우에만 거짓의 진리 값을 가진다. A B A ∨\\lor∨ B true true true true false true false true true false false false 4. 베타적 논리합두 명제에 대해 동시에 만족하는 경우를 배척하는 논리합이다. 하나의 명제가 참이고 다른 하나의 명제가 거짓일 때 참의 진리 값을 갖고, 그렇지 않으면 거짓의 진리 값을 가진다. A B A ⊕\\oplus⊕ B true true false true false true false true true false false false 5. 등치: A === B두 명제가 모두 참인거나 거짓일 때 참의 진리 값을 가진다. A B A === B true true true true false false false true false false false true 6. 조건: A →\\rightarrow→ B A 이면 B이다. A는 B의 충분조건이다.(충분조건: 어떤 명제가 만족되었을 때 진술의 참을 보장하는 조건 ) B는 A의 필요조건이다.(필요조건: 어떤 명제가 참이기 위해 반드시 충족되어야 하는 조건 ) A는 B를 함축한다. (A ⊃\\supset⊃ B)가정(A)이 참일 때 결론(B)이 거짓이면 거짓의 진리 값을 가진다. A B A →\\rightarrow→ B true true true true false false false true true false false true 여기서 주목할 점은 가정(A)이 거짓인 경우 결론(B)의 진리 값이 무엇이든 상관없이 조건 명제에 대한 진리 값은 참이다.7. 쌍방진리 값은 A, B가 모두 참이거나 거짓일 때 참의 값을 가지고, 그 외에는 거짓의 값을 가진다.이는 필요충분 조건으로 등치(===)와 진리 값이 같다. A B A ↔\\leftrightarrow↔ B true true true true false false false true false false false true 예시 (합성명제 예시 1) 다음 식의 진리 표를 만드시오 ∽(A∨B) \\backsim( A \\lor B ) ∽(A∨B) (답) A B A ∨\\lor∨ B ∽\\backsim∽( A ∨\\lor∨ B ) true true true false true false true false false true true false false false false true (합성명제 예시 1) 다음 식의 진리 표를 만드시오 A∨(B∧C) A\\lor( B \\land C ) A∨(B∧C) (답) A B C B ∧\\land∧ C A∨\\lor∨( B ∧\\land∧ C ) true true true true true true true false false true true false true false true true false false false true false true true true true false true false false false false false true false false false false false false false 드모르간 법칙논리적 동치 관계명제 p, q의 쌍방 조건 p ↔\\leftrightarrow↔ q 가 항상 참인 경우, 두 명제 p, q는 논리적 동치이고 p ⇔\\Leftrightarrow⇔ q 라 표현한다. 즉, 명제 p와 q는 같은 논리 값을 가진다는 의미이다. 두 명제가 논리적 동치일 경우, 논리 값이 서로 같으므로 하나의 명제가 다른 명제를 대신 할 수 있다. 어떤 복잡한 명제를 좀 더 간단한 명제로 만들기 위해 논리적 동치 관계인 다른 명제를 사용하여 간소화 한다.이러한 논리적 동치 관계의 기본 법칙 중 하나가 드모르간의 법칙이다. 드모르간 법칙∽(A∨B)⇔ ∽A ∧∽B \\backsim (A \\lor B) \\Leftrightarrow \\space \\backsim A \\space\\land \\backsim B ∽(A∨B)⇔ ∽A ∧∽B∽(A∧B)⇔ ∽A ∨∽B \\backsim (A \\land B) \\Leftrightarrow \\space \\backsim A \\space\\lor \\backsim B ∽(A∧B)⇔ ∽A ∨∽B카르노 맵카르노 맵은 복잡한 논리식을 시각적으로 표현해 좀 더 간소화 시키는 방법이다.정의되지 않음(undefined)을 포함한 논리1. 조건 논리곱 ( &amp;&amp; ): A &amp;&amp; B A B A &amp;&amp; B true true true true false false true undefined undefined false true false false false false false undefined false undefined true undefined undefined false undefined undefined undefined falundefinedse 2. 조건 논리합 ( || ): A || B A B A || B true true true true false true true undefined true false true true false false false false undefined false undefined true undefined undefined false undefined undefined undefined undefined 3. 3값 논리의 부정 (!): !A A !A true false false true undefined undefined 3값 논리에서 드모르간 법칙 !(A &amp;&amp; B)=(!A) ∣∣ (!B) \\space!(A\\space\\&amp;\\&amp;\\space B) = (!A)\\space||\\space(!B)  !(A &amp;&amp; B)=(!A) ∣∣ (!B)  !(A ∣∣ B)=(!A) &amp;&amp; (!B) \\space!(A\\space||\\space B) = (!A)\\space\\&amp;\\&amp;\\space(!B) !(A ∣∣ B)=(!A) &amp;&amp; (!B)" }, { "title": "Jekyll을 이용하여 블로그에 Katex 적용하기", "url": "/posts/adjust-katex/", "categories": "Github 블로그 만들기", "tags": "github, 블로그, jekyll, chirpy, Katex", "date": "2022-05-04 23:16:00 +0900", "snippet": "Katex란?Katex는 웹 상에 수식 표기를 해주는 라이브러리 중 하나이다.웹 상에 수학 수식을 입력하는 방법들 중 제일 간편하다고 생각한다.문법만 어느 정도 숙달 된다면 이만큼 수식 표현하기 좋은 방법도 없다고 생각한다. 해당 링크를 통해 Katex의 전반적인 문법을 한눈에 살펴볼 수 있다.Katex는 엄연히 라이브러리이기 때문에 적용법을 알아야 한다.여기서는 Jekyll에서 Katex를 적용하는 방법에 대해서 알아보고자 한다.(Chirpy 테마를 기준으로 설명하기 때문에 다른 테마는 적용법이 다를 수 있음을 참고하자.)Jekyll-KatexKatex 라이브러리를 위한 Jekyll 플러그인을 적용해보자.설치 및 세팅_config.yml 수정설정 파일 _config.yml에서 맨 마지막에 jekyll-katex를 추가한다.# 추가 플러그인plugins: - jekyll-katexGemfile 수정Gemfile 루비 파일에서 플러그인 블록에 jekyll-katex를 추가한다.group :jekyll_plugins do gem 'jekyll-katex'endbundler를 이용해 설치bundler를 이용하여 라이브러리에 필요한 파일들을 설치한다. 터미널을 이용하여 다음 명령어를 입력하자.bundle installKatex 스타일 추가이제 Katex용 CSS 파일과 폰트를 추가한다.로컬상에 설치하여 세팅해도 되지만 여기서는 외부문서로 연결한다.(로컬 설치가 궁금한 사람들은 해당링크를 참조하자.)head.html 파일에서 포스팅 시 적용되는 블록을 찾는다.그리고 다음 내용을 추가한다.&lt;!-- KaTeX CSS --&gt;&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css\" integrity=\"sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq\" crossorigin=\"anonymous\"&gt;사용 방법두 가지 방법이 있다. katex liquid 태그를 이용하는 방법 katexmm liquid 태그를 이용하는 방법katex의 경우 수식부분만 liquid 태그로 감싸줘야 하는 번거로움이 있다. 수식을 제외한 나머지 내용들도 모두 수식화 되어버리기 때문이다.여기서는 katexmm을 이용한 방법을 설명한다. katexmm은 liquid 태그만 한번 감싸주면 수식모드( $, $$ )로 간편하게 수식을 추가할 수 있기 때문에 굉장히 편하다. 수식이 필요한 포스팅의 경우 마크다운 파일의 양끝을 liquid 태그로 감싸면 된다.위와 같이 중간에 수식모드를 사용하면 포스팅시 멋진 수식으로 변환되는 것을 볼 수 있을 것이다.주의사항여기서 주의해야 할 점이 있는데 katexmm liquid 태그로 감싸져 있는 경우, $ 문자를 사용할때 빌드 에러가 생기거나, 포스팅 내용이 의도하지 않게 수식화 되는 문제가 있다.그렇기 때문에 때문에 $ 문자를 사용하고 싶은 경우에는 katexmm liquid 태그 외부에 작성해야 한다.$$(Katex Display 모드) 적용 문제 해결$는 잘 되는데 $가 수식으로 적용되지 않는다면, Katex가 아닌 Jekyll 자체에서$에 대해 수식 변환을 시도하는 것이 원인일 수 있다.(https://github.com/linjer/jekyll-katex/issues/29)이런 경우 _config.yml파일에 다음 내용을 추가하면 해결 할 수 있다.kramdown: # (중간 내용 생략...) math_engine: null # 추가, For Katex display mode" }, { "title": "Jekyll을 이용하여 Chirpy 테마 블로그 만들기(MacOS)", "url": "/posts/making-blog/", "categories": "Github 블로그 만들기", "tags": "github, 블로그, jekyll, chirpy, mac, macOS", "date": "2022-05-04 11:15:00 +0900", "snippet": "1. 들어가면서요즘 깃허브 블로그를 시작하는 분들이 많은데, 방법을 몰라서 헤매는 분들이 많을거라고 생각된다. 개발을 전혀 모르시는 분이라면 어렵고, 헷갈린다..나 또한 블로그 처음 만들때 하루 종일 걸렸던 기억이 있다. 본인처럼 고통받는 사람이 더 이상 없기를 하는 마음에서 포스팅을 작성한다.2. 사전 환경해당 블로그 만들기는 Chirpy라는 테마를 적용하기 때문에 이에 맞춰 설명한다.사전에 필요한 환경과 프로그램은 다음과 같다. MacOS (본인은 Catalina 10.15.7 버전이지만, 버전은 상관없으리라..) 64bit Git, Github Desktop Visual Studio Code3. Jekyll 환경 설치 및 세팅우선 테마 적용에 앞서서 필요한 것 부터 설치하고 세팅하도록 하자. 먼저 터미널을 연다.3-1. Command Line Tools 설정먼저, Native 확장기능을 컴파일할 수 있게 해주는 명령행 도구를 설치해야 하므로, 다음 명령어를 터미널에 입력한다.xcode-select --install3-2. 루비 설치Jekyll은 루비 2.4.0 버전 이상을 필요로 한다. 여기서는 2.6.3 버전을 기준으로 기본적으로 Catalina 10.15는 루비 2.6.3이 기본 포함되어 있으므로 아무런 문제가 없다.이전 버전을 MacOS 시스템을 사용중이라면, 새로운 버전의 루비를 설치해야 한다.Homebrew 설치rbenv를 설치하기 위해서는 Homebrew가 필요하다.# Homebrew 설치/usr/bin/ruby -e \"\\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"rbenv 설치 및 사용많은 사람들이 rbenv로 여러 루비를 관리한다. 각각의 프로젝트마다 다른 버전의 루비를 실행해야 할 때 아주 유용하다.# rbenv 와 ruby-build 설치brew install rbenv# 쉘 환경에 rbenv 가 연동되도록 설정rbenv init# 만약에 해당 명령어 실행시# Load rbenv automatically by appending...# 이 뜨는 경우 해당 명령어를 추가로 수행해준다.eval \"\\$(rbenv init - bash)\"# 설치 상태 검사curl -fsSL https://github.com/rbenv/rbenv-installer/raw/HEAD/bin/rbenv-doctor | bash# OK가 모두 떠야한다.터미널을 재시작하면 변경사항이 적용된다. 이제 원하는 버전의 루비를 설치할 수 있다.rbenv install 2.6.3rbenv global 2.6.3ruby -v# 해당 줄이 출력되면 정상ruby 2.6.3p62 (2019-04-16 revision 67580) 3-3. Jekyll 설치이제 gem을 이용해 Jekyll에 필요한 프로그램들을 설치한다.gem install --user-install bundler jekyll설치된 루비 버전을 확인한다.ruby -vruby 2.6.3p62 (2019-04-16 revision 67580) 이제 아래 내용을 쉘 환경에 추가한다.echo 'export PATH=\"\\$HOME/.gem/ruby/2.6.0/bin:\\$PATH\"' &gt;&gt; ~/.bash_profile# 바로 적용source ~/.bash_profile그 다음으로 Gem 경로가 홈 디렉토리를 가리키고 있는지 다음 명령어를 실행하여 확인한다.gem envGEM PATHS: 가 홈 디렉토리 내 경로를 가리키고 있는지 확인한다. 4. 블로그 리포지토리 생성 및 설정4-1. 리포지토리 생성블로그로 사용할 리포지토리를 생성한다.리포지토리의 이름은 &lt;깃허브닉네임&gt;.github.io으로 해야 한다. 이미 이러한 이름의 리포지토리를 가지고 있다면 삭제부터 하고 다시 시도하자.( 본인은 이미 같은 이름으로 만들어 놨기 때문에 에러가 뜬다. )4-2. 리포지토리 설정사전 설정이 필요한 부분은 두 가지이다.main 브렌치 이름 변경chirpy 테마 기준에 맞추기 위해 main 브랜치의 이름을 master로 변경한다. 우선 리포지토리에서 Settings &gt; Branches에 들어간다. 그리고 브랜치의 이름을 master로 변경한다.자동배포 설정블로그 작업 내용을 깃허브가 자동으로 배포할 때 읽기, 쓰기 권한을 부여해야 한다. 그렇지 않으면 빌드에 실패하게 된다.Settings &gt; Actions &gt; General로 이동하여 다음 사진처럼 설정한다. 4-3. 리포지토리 클론Github Desktop을 이용하여 생성한 리포지토리를 클론해준다.5. Chirpy 테마 적용5-1. Chirpy 테마 초기화이제 Chirpy 테마를 적용할 차례이다. jekyll-theme-chirpy 링크로 들어가서 zip파일을 다운로드 받는다.압축을 풀면 다음과 같은 파일들이 있다. 숨김파일까지 모두 복사한다.(숨김파일이 안보인다면 command(⌘) + shift + . 을 입력하자)이제 복사한 파일들을 리포지토리로 옮긴다. 5-2. _config.yml 수정Github Desktop에서 Open In Visual Studio Code 버튼을 눌러 로컬파일을 VSCode로 연다._config.yml 파일을 찾아 알맞은 설정값으로 수정해야 한다.theme: jekyll-theme-chirpy # import하는 테마 명입니다. 디폴트로 사용중인 테마 명이 들어가 있으므로, 수정은 하지 않습니다.baseurl: '' # 사용자 페이지를 만들었을 경우, 빈칸으로 둡니다. 프로젝트 페이지를 만든 경우 프로젝트 명을 적어줍니다.lang: ko-KR # 사용하는 언어 설정을 진행합니다. http://www.lingoes.net/en/translator/langcode.htm 로 접속하여 확인가능합니다.timezone: Asia/Seoul #timezone설정입니다. http://www.timezoneconverter.com/cgi-bin/findzone/findzone 에서 확인가능합니다.# jekyll-seo-tag settings › https://github.com/jekyll/jekyll-seo-tag/blob/master/docs/usage.md# ↓ --------------------------title: Lipcoder # 블로그 이름입니다. 설정하면 브라우저 상단에 설정된 이름이 확인가능합니다.tagline: Lipcoder Sub # 서브 타이틀 입니다. 설정하면 블로그 첫 페이지 좌측에서 확인 가능합니다.description: # \"used by seo meta and the atom feed\"라고 나옵니다. 저는 설정을 그대로 두었습니다.url: 'https://lipcoder.github.io' # 'https://username.github.io'와 같이 설정합니다. 설정이 잘 못 되면 곤란합니다.# 잘 적어넣도록 합니다.github:username: lipcoder # 본인의 github username을 적습니다.#twitter:# username: twitter_username # 본인의 twitter username을 적습니다. 저는 트위터는 사용하지 않아 주석 처리 해 두었습니다.social:# Change to your full name.# It will be displayed as the default author of the posts and the copyright owner in the Footername: Lipcoderemail: sb921204@naver.com # change to your email addresslinks:# The first element serves as the copyright owner's link#- https://twitter.com/username # change to your twitter homepage- https://github.com/LipCoder # change to your github homepage# Uncomment below to add more social links# - https://www.facebook.com/username# - https://www.linkedin.com/in/username# 상단은 social관련 내용입니다. 본인의 이름, 이메일, 링크 등을 작성합니다. 저는 깃허브만 올려두었습니다.google_site_verification: 000 # Google Search Console관련 내용입니다. 이후 포스팅에서 다루겠습니다.# ↑ --------------------------google_analytics:id: '000' # Google Analytics ID입니다. 이 또한 이후 포스팅에서 다루겠습니다.pv:proxy_endpoint:cache_path:theme_mode: # chirpy테마는 [light|dark]테마를 지원합니다. 비워두시면 사용자의 디폴트 값이 설정되고, light 또는 dark로 입력해두시면 페이지의 기본 테마가 설정됩니다.img_cdn: '' #cdn 이미지 설정입니다. 저는 따로 진행하지 않았으나 진행하시려면 url을 작성해주시면 됩니다.avatar: /assets/img/profile.png # 대표이미지 라고 생각하시면 됩니다. /assets/img경로에 사진을 넣은 뒤 작성하시면 됩니다.toc: true # toc(Table of contents)입니다. 블로그 보시다 보면 포스팅 옆에서 스크롤을 따라오는 목차같은 녀석이 있습니다.# 사용하시려면 true, 아니라면 false를 적으시면 됩니다.disqus:comments: true # disqus라는 덧글기능을 하는 녀석입니다. 사용하시려면 true, 아니라면 false를 적으시면 됩니다.shortname: '' # 사용하신다면 https://disqus.com/ 에 가입 후, shortname을 넣어줍니다.paginate: 10# ------------ 아래로는 크게 손 볼 것 없어서 생략합니다. ------------------추가 설정을 하고 싶은 경우 https://github.com/cotes2020/jekyll-theme-chirpy 으로 접속하면 더 다양한 내용을 찾아 볼 수 있다. 이제 Github Desktop을 이용하여 Commit 한 후 Push를 해주자. 5-3. Jekyll로 Chirpy 테마 초기화Chirpy를 테마로 사용하기 위해서는 초기화를 한 번 해줘야 한다.# 리포지토리 경로상으로 이동한다.cd [깃허브 폴더 경로]/lipcoder.github.io# chirpy를 초기화bash tools/init.sh[INFO] Initialization successful! # 이런 메세지가 나오면 성공!이제 Chirpy에 필요한 의존성 있는 모듈들을 모두 설치해야 한다. 이미 Chirpy에 기본설정이 되어 있기 때문에 해당 명령만으로 모든 것이 설치된다.# 의존 모듈을 설치한다.bundle많은 내용들이 설치되는 것을 볼 수 있다. 그리고 다음 명령을 사용해 jekyll을 실행한다.jekyll serve정상적으로 수행되었다면 다음과 같이 출력된다.이제 브라우저에서 http://localhost:4000/ 이나 http://127.0.0.1:4000/으로 접속하면 기본 블로그 화면이 나타날 것이다.위 화면이 잘 나오면 로컬 테스트는 성공이다.5-4. ‘.gitIgnore’ 편집배포를 하기전에 Gemfile.lock 파일을 제외하는 설정을 먼저 해줘야 한다. 이 파일이 git에 올라가면 빌드/배포 에러를 내는 경우가 많기 때문이다..gitignore파일을 열어서 아래 내용을 한 줄 추가한 후 저장한다.Gemfile.lock이제 모든 내용을 Github Desktop을 이용하여 Commit 한 후 Push를 해주자. 5-5. 배포Push를 마치면 github는 자동으로 블로그 페이지를 만들어 준다. 시간이 좀 걸리기 때문에 잘 빌드가 되고 있는지 살펴보자.github 저장소에 가보면, Actions 라는 상단 탭이 있다. 이를 클릭해보면 아래와 같이 나타난다.정상적으로 빌드/배포를 마쳤다면 초록색 아이콘이 생긴다.소스를 push하면, github는 자동으로 page build와 deployment를 수행한다. 이제 중요한 것이 있는데, github에서 gh-pages라는 브렌치를 자동으로 생성해 준다는 것이다.블로그 사이트는 실제로 이 브랜치에서 실제 내용이 구성된다. 우리가 Push한 브랜치는 master이고, 여기에는 사이트에 대한 기본 구조가 없기 때문이다. 5-6. 서비스용 브랜치 변경하기저장소에서 Settings &gt; Pages탭으로 이동하면, 브렌치 설정을 할 수 있는데 여기서 브렌치를 gh-pages로 변경한 후 Save 버튼을 클릭한다. 6. 블로그 확인하기자동 배포가 완료되면 블로그 세팅이 완료된 것이다. https://&lt;github닉네임&gt;.github.io/ 로 접속하여 본인의 블로그가 잘 나오면 성공한 것이다. 참고 :https://www.irgroup.org/posts/jekyll-chirpy/https://wlqmffl0102.github.io/posts/Making-Git-blogs-for-beginners-3/" }, { "title": "0 이야기", "url": "/posts/decrete-math/", "categories": "이산수학", "tags": "이산수학, 표기법, 자리표기법, 진법변환, 0의역할", "date": "2022-05-01 18:53:51 +0900", "snippet": "숫자표기법자리표기법기수(base, 밑수) 와 지수를 이용하여 숫자를 표기하는 방법이다.10진법을 예로 들면, 기수는 10이 되고, 지수는 정수로서 숫자의 각 자리를 표현하는 역할을 한다. ex) 2진법, 10진법, 16진법, … 로마숫자 표기법고대 로마시절 쓰인 기수법으로 자리표기법을 사용하지 않는 표기법이다. ex) I,II,III,IV,V,... I, II, III, IV, V, ... I,II,III,IV,V,...다음과 같은 특징이 있다. 숫자 자리는 의미가 없고, 숫자 자체가 그 수를 나타냄 0이 없음 Ⅰ(1),Ⅴ(5),Ⅹ(10),L(50),C(100),D(500),M(1000)Ⅰ(1), Ⅴ(5), Ⅹ(10), L(50), C(100), D(500), M(1000)Ⅰ(1),Ⅴ(5),Ⅹ(10),L(50),C(100),D(500),M(1000) 등의 문자를 사용 나열한 문자가 나타내는 수를 모두 더한 것이 전체 수10진법사용하는 숫자 0,1,2,3,4,5,6,7,8,90, 1, 2, 3, 4, 5, 6, 7, 8, 90,1,2,3,4,5,6,7,8,9 (총 10개)일상생활에서 사용되는 진법으로 우리에게 가장 익숙한 진법이다.표현 예시2503을 10진법으로 표현하면 다음과 같다. 250325032503 222 &lt;— 1000의 개수(2) 1000의 자리(10310^3103)555 &lt;— 100의 개수(5) 100의 자리(10210^2102)000 &lt;— 10의 개수(0) 10의 자리(10110^1101)333 &lt;— 1의 개수(3) 1의 자리(10010^0100) =2×103+5×102+0×101+3×1= 2 \\times 10^3 + 5 \\times 10^2 + 0 \\times 10^1 + 3 \\times 1=2×103+5×102+0×101+3×12진법사용하는 숫자 0,10, 10,1 (총 2개)컴퓨터를 다룰 때 사용하는 진법으로 매우 단순하지만, 숫자 표현을 위한 자릿수가 많다.표현 예시1100을 10진법으로 표현하면 다음과 같다. 110011001100 111 &lt;— 8의 개수(1) 8의 자리(232^323)111 &lt;— 4의 개수(1) 4의 자리(222^222)000 &lt;— 2의 개수(0) 2의 자리(212^121)000 &lt;— 1의 개수(3) 1의 자리(202^020) =1×23+1×22+0×21+0×20= 1 \\times 2^3 + 1 \\times 2^2 + 0 \\times 2^1 + 0 \\times 2^0=1×23+1×22+0×21+0×20=12= 12=12진법 변환다른 진법끼리 변환이 가능하며 특정한 규칙을 가진다.여러가지 변환 방법이 존재하지만, 간단하게 10진법을 2진법으로 변환하는 방법을 살펴보고 넘어가도록 하겠다.10진법 to 2진법2로 더 이상 나눌 수 없을 때 까지 나눠준다.그 후 마지막 몫 부터 차례대로 나머지를 나열하면 2진법으로 변환된다.컴퓨터에서 2진법을 사용하는 이유사람의 입장에서 본다면 2진법은 10진법 보다 다루기가 까다롭다. 그렇다면 컴퓨터는 왜 10진법이 아닌 2진법을 사용하는 것일까?컴퓨터의 숫자 표현 방법컴퓨터는 전자회로로 만들어진 스위치의 전기적 신호를 이용하여 숫자를 표현한다.10진법을 기준으로, 스위치의 신호를 10개의 상태로 만들었다고 가정하자. 한 자릿수에 대해 덧셈표를 작성하면 다음과 같다.그저 한 자릿수만 다루는 데에도 이렇게 복잡한 표가 나오게 된다. 반면, 2진법으로 스위치 신호를 2개의 상태로 덧셈표를 작성하면 다음과 같다.10진법과 다르게 자릿수가 많아져도 복잡도는 커지지 않고, 오히려 더 많은 숫자를 표현할 수 있게 된다.컴퓨터의 특징 아주 빠른 계산이 가능 계산 실수가 없음 직관적인 수 파악이 필요 없음 (사람=10진법) 계산 규칙이 간단한 것을 선호이러한 이유로 컴퓨터에서는 2진법을 사용하는 것이다.0의 역할자리 표기 (자리 확보)2503이라는 숫자에서 0의 역할에 대해 생각해보자.2503의 0은 10의 자리가 ‘없다’라는 것을 나타낸다. 단순히 없다고 해서 0을 생략할 수는 없다. 0을 생략하여 253이라고 쓰면 전혀 다른 숫자가 되기 때문이다. 2503=253(X)2503 = 253(X)2503=253(X)자리 표기법에서는 자리에 중요한 의미가 있으므로 자릿수가 없어도 그곳에 무언가 숫자를 두어야 한다.즉, 0의 역할을 자리를 확보하는 것이다. 자리 표기법에서는 0이 반드시 있어야 함을 의미한다.지수 법칙 성립10진법을 설명할 때 ‘1은 10의 0승’ 이라는 표현이 있다. 100=110^0 = 1100=1‘10^1^은 10’, ‘10^2^은 100’으로 유추해 볼 수 있듯, ‘10의 n승은 10을 n번 곱한 수’이다. 유추를 통해 ‘10의 0승은 10을 0번 곱한 수’인데 이 값이 1이 된다는 것은 뭔가 이상하다.10^0^은 어떻게 정의하여야 타당할까? 10^3^은 1000이고, 10^2^는 100이다. 이 식을 나열하여 규칙성을 찾아보자. 103=100010^3 = 1000103=1000(1000×110)(1000 \\times \\frac{1}{10})(1000×101​)102=10010^2 = 100102=100(100×110)(100 \\times \\frac{1}{10})(100×101​)101=1010^1 = 10101=10(10×110)(10 \\times \\frac{1}{10})(10×101​)100=110^0 = 1100=1지수가 1 감소할 때마다 수는 10분의 1로 줄어든다. 그렇다면 10^0^은 1이 될 거라고 생각하는 것이 타당할 것이다.0을 이용하여 지수 법칙을 성립 시킬 수 있게 된 것이다. Na×Nb=Na+bN^a \\times N^b = N^{a+b}Na×Nb=Na+b102×10−2(a=2,b=−2)10^2 \\times 10^-2 (a=2, b=-2)102×10−2(a=2,b=−2)=100×1100= 100 \\times \\frac{1}{100}=100×1001​=1= 1=1즉, 여기서 0의 역할은 규칙을 간단히 하기 위한 값이다. 한계를 넘기 위해이제 조금 더 근본적인 문제를 생각해 보도록 하자.인간은 왜 수를 표기하는 방법을 고안했을까? 그것은 바로 수가 커질수록 다루기가 어렵기 때문이다.자리 표기법을 이용하면, 큰 수를 자릿수 별로 나누어 간단하게 표현할 수 있다.한계를 극복하는 방법여기서 얻을 수 있는 교훈이 있는데, 그것은 바로 커다란 문제는 작은 '덩어리'로 나누어 푼다.는 것이다.만약 인간이 수를 인지하는 능력이 더 뛰어났다면, 덩어리를 만들어 정리하고 수를 표시하는 방법은 발달하지 않았을지도 모른다.이는 단순히 숫자 표현에만 국한되지 않는다. 이러한 해법은 현대에도 적용된다.우리는 컴퓨터를 사용하여, 인간의 능력으로 풀 수 없는 큰 단위의 문제를 풀고자 한다.프로그래밍을 통해 거대한 규모의 문제를 얼마나 빠르게 해결하는가에 노력을 기울인다. 커다란 문제를 풀 때는 여러개의 작은 덩어리로 나누자.나눈 덩어리가 여전히 크다면 더 작은 덩어리로 나누자.적당히 작아졌다면 드디어 이 문제를 풀자.대규모의 프로그램을 만들 때도 여러 개의 작은 프로그램(모듈)으로 나누어 개발하는 것이 일반적이다. " }, { "title": "첫 포스팅 작성하기", "url": "/posts/Writing-The-First-post-2/", "categories": "TEST_CATEGORIE, TEST_SUB_CATEGORIE", "tags": "TAG, TEST", "date": "2022-05-01 17:13:00 +0900", "snippet": "" } ]
